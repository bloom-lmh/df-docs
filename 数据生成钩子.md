# 数据生成钩子

## 介绍

前面在模板语法部分介绍过上下文对象，通过上下文对象能够获取并操作到部分已经生成的数据，然而上下文对象只能在模板中进行使用，且只能操作局部数据。如果想要在后续的处理过程中使用到这些数据，并对这些数据产生影响，就需要使用到后处理器。

## 全局定义后处理器

### 基本语法

后处理器可以是一个函数也可以是一个函数数组，数组中的函数会按顺序执行，并且函数可以接受一个参数，这个参数是生成后的或前一个处理器处理后的数据。全局设置后处理器的方式如下所示：
::: code-group

```ts [设置单个后处理器]
DataFaker.setCallbacks((data) => {
  data['id'] = faker.string.uuid();
  return data;
});
```

```ts [设置多个后处理器]
DataFaker.setCallbacks([
  (data) => {
    data['id'] = faker.string.uuid();
    return data;
  },
  (data) => {
    data['created_at'] = new Date().toISOString();
    return data;
  },
]);
```

:::

### 使用示例

> 案例：比如我希望为所有生成的数据加上`id`，那么我可以配置全局后处理器，这样所有模型在生成数据时都会自动加上`id`属性了。如下所示：

::: code-group

```ts {1-4}[代码]
DataFaker.setCallbacks((data) => {
  data['id'] = faker.string.uuid();
  return data;
});
// 用户模型
const userModel = defineModel('user', {
  firstName: 'person.firstName',
  secondName: 'person.lastName',
  age: ['number.int', { min: 18, max: 65 }],
  email: (ctx) => {
    return faker.internet.email({ firstName: ctx.firstName, lastName: ctx.secondeName });
  },
});
DataFaker.setLocale('zh_CN');
const userDatas = fakeData(userModel);
console.dir(userDatas, { depth: Infinity });
// 公司模型
const companyModel = defineModel('company', {
  name: 'company.name',
  address: 'location.streetAddress',
});
const companyDatas = fakeData(companyModel);
console.dir(companyDatas, { depth: Infinity });
```

```json {7,12} [结果]
// 生成的数据如下,可见数据中都包含 id 属性：
{
  "firstName": "晓啸",
  "secondName": "靳",
  "age": 62,
  "email": "k7ngvs.Heidenreich92@yahoo.com",
  "id": "c39be576-95fa-4e77-92ed-c621640f3695"
}
{
  "name": "贵阳市琪印刷有限公司",
  "address": "旷街6号",
  "id": "0b80ab0f-ba3f-4215-ac56-95c8a8940bdb"
}
```

:::

## 运行时指定后处理器

### 基本语法

所谓在运行时指定后处理器就是通过`fakeData`方法的第二个参数指定，其接受的类型与全局后处理器一致，如下所示：

::: code-group

```ts [指定单个后处理器]
const userDatas = fakeData(userModel, {
  callbacks: (data) => {
    data['sex'] = 'male';
    return data;
  },
});
```

```ts [指定多个后处理器]
const userDatas = fakeData(userModel, {
  callbacks: [
    (data) => {
      return {
        sex: 'male',
        ...data,
      };
    },
    (data) => {
      data.firstName = data.firstName.toUpperCase();
      return data;
    },
  ],
});
```

:::

### 使用示例

> 比如下面的案例中为数据添加`sex`属性并将`firstName`全部转为大写

::: code-group

```ts [代码] {10-23}
// 用户模型
const userModel = defineModel('user', {
  firstName: 'person.firstName',
  secondName: 'person.lastName',
  age: ['number.int', { min: 18, max: 65 }],
  email: (ctx) => {
    return faker.internet.email({ firstName: ctx.firstName, lastName:
  },
});
const userDatas = fakeData(userModel, {
  callbacks: [
    (data) => {
      return {
        sex: 'male',
        ...data,
      };
    },
    (data) => {
      data.firstName = data.firstName.toUpperCase();
      return data;
    },
  ],
});
```

```ts [结果]
{
  sex: 'male',
  firstName: 'LAVERNA',
  secondName: 'Hand',
  age: 62,
  email: 'Laverna76@yahoo.com'
}
```

:::

### 配置合并

运行时配置中的处理器将会与全局处理器进行合并，比如下面的案例中，全局处理器为所有模型生成的数据添加了`id，而对于user模型则添加`sex`属性并将`firstName`全部转为大写：

::: code-group

```ts [代码] {10-23}
// 用户模型
const userModel = defineModel('user', {
  firstName: 'person.firstName',
  secondName: 'person.lastName',
  age: ['number.int', { min: 18, max: 65 }],
  email: (ctx) => {
    return faker.internet.email({ firstName: ctx.firstName, lastName:
  },
});
const userDatas = fakeData(userModel, {
  callbacks: [
    (data) => {
      return {
        sex: 'male',
        ...data,
      };
    },
    (data) => {
      data.firstName = data.firstName.toUpperCase();
      return data;
    },
  ],
});
```

```ts [结果]
{
  sex: 'male',
  firstName: 'LAVERNA',
  secondName: 'Hand',
  age: 62,
  email: 'Laverna76@yahoo.com'
}
```

:::
