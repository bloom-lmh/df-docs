# 模板语法

`DataFaker`通过模板来定义数据结构，就像定义一个数据库表那样，每一个数据结构就是一个`schema`

## 使用预提供的数据类型

`DataFaker` 提供了 26 种，200 多个常用数据项，你可以直接使用他们，基本语法为：

1. `字段：类型字符串`
2. `字段:[类型字符串,方法参数]`

如下所示：

::: code-group

```ts [路径字符串形式]
const userSchema: ModelSchema = {
  id: 'string.uuid',
  name: 'person.fullName',
  // 数组形式，第一个参数为方法路径，第二个为方法参数
  age: ['number.int', { min: 18, max: 30 }],
};
```

```js [原生faker.js定义形式]
const user = {
  id: faker.string.ulid(),
  name: faker.person.fullName(),
  age: faker.number.int({ min: 18, max: 30 }),
};
```

:::

<GlassCard>
<template #title>自动类型提示</template>
<template #description>DataFaker 借助 ts 实现了数据类型提示，所以你在定义Schema时必须标注ModelSchema类型，这样可以很方便的使用各种类型提示，而不用繁琐的去进行方法调用</template>
<template #content>
 <img src="https://image-bucket-1307756649.cos.ap-chengdu.myqcloud.com/image/20251004101219447.png" alt="" />
</template>
</GlassCard>

## 自定义数据类型

### getter 函数

如果你需要自定义数据，你可以使用一个`getter`函数来返回你想要的数据，基本语法为:

```js
{
  字段: () => {
    return 自定义数据;
  };
}
```

如下所示：

```ts {4-7}
const userModel = defineModel('user', {
  id: 'string.uuid',
  age: ['number.int', { min: 18, max: 30 }],
  name: () => {
    return `__${faker.person.fullName()}`;
  },
  sex: () => '男',
});
```

::: tip defineModel
`defineModel` 是 `DataFaker` 提供的函数，用来定义数据模型，返回一个 `DModel` 对象。它接受两个参数:

- 模型名称: `string`
- 模型模板: `ModelSchema`

如果你这么做，这个模型将会被注册到 `DataFaker` 中，你可以在其他地方使用 `fakeData` 函数来生成数据。
:::

### 上下文信息

当然为了保持生成数据的关联性，`DataFaker`使用了上下文机制，即在`getter`函数种可以接受一个上下文对象，这个对象包含了前面已经生成的字段数据，这样你在 `getter` 函数种就可以利用他们来保持数据的关联性了。

比如我希望生成的邮箱数据中使用用户的姓名，这样会让邮箱数据生成的更加合理

```ts {4-9}
const userModel = defineModel('user', {
  id: 'string.uuid',
  age: ['number.int', { min: 18, max: 30 }],
  fName: 'person.firstName',
  lName: 'person.lastName',
  email: (ctx) => {
    // 使用已经生成的fName和lName数据
    return faker.internet.email({ firstName: ctx.fName, lastName: ctx.lName });
  },
});
const users =
```

可以看到邮箱数据就与 `fName` 和 `lName` 数据关联了起来

```bash {4-6}
{
  id: '1cdef7cf-76f7-459f-a250-3823cad6ead1',
  age: 24,
  fName: 'Brycen',
  lName: 'Johnson',
  email: 'Brycen.Johnson@gmail.com'
}
```

## 引用数据类型

### 基本语法

`DataFaker` 支持引用数据类型，即你可以在一个数据结构中引用另一个数据结构，这样可以让数据结构更加灵活，基本语法为：

```ts
{
  字段: {
    refModel: '模型名称' | '模型对象';
    // 生成数量
    count?: number;
    // 递归深度
    deep?: number;
  },
  // 或者，此时count和deep属性默认为1
  字段:'模型名称' | '模型对象'
}
```

### 引用其它模型

比如下面的案例中用户模型引用了地址模型，这样可以生成用户模型时同时生成地址模型的数据

```ts {2-5,16-22}
// 地址模型
const addressModel = defineModel('address', {
  country: 'location.country',
  city: 'location.city',
});
// 用户模型
const userModel = defineModel('user', {
  id: 'number.int',
  firstName: 'person.firstName',
  secondeName: 'person.lastName',
  age: ['number.int', { min: 18, max: 65 }],
  hobby: ['helpers.arrayElements', ['篮球', '足球', '乒乓球', '羽毛球']],
  email: ctx => {
    return faker.internet.email({ firstName: ctx.firstName, lastName: ctx.secondeName });
  },
  // 引用地址
  address: addressModel,
  // 带规则
  address2: {
    refModel: 'address',
    count: 3,
  },
});
const userDatas = fakeData(userModel, {
  // 数据两为2
  count: 2,
});
console.log(userDatas);
```

生成的数据如下

```bash {7-12}
{
  id: 2769029318500197,
  firstName: 'Alvah',
  secondeName: 'Luettgen',
  age: 62,
  hobby: [ '篮球', '羽毛球', '乒乓球' ],
  address: { country: 'Malta', city: 'Konopelskistead' },
  address2: [
    { country: 'Bahamas', city: 'Glen Burnie' },
    { country: 'Gambia', city: 'Port Alden' },
    { country: 'Rwanda', city: 'New Rosannaville' }
  ],
  email: 'Alvah_Luettgen@hotmail.com'
}
```

### 自引用

`DataFaker`同时支持自引用，这在生成树状数据时十分有用，但是要注意，自引用只能使用模型别名，否则会提示循环引用。
下面的案例中将会生成一个树状结构数据：

```ts {15-20}
const addressModel = defineModel('address', {
  country: 'location.country',
  city: 'location.city',
});
const userModel = defineModel('user', {
  id: 'number.int',
  firstName: 'person.firstName',
  secondeName: 'person.lastName',
  age: ['number.int', { min: 18, max: 65 }],
  hobby: ['helpers.arrayElements', ['篮球', '足球', '乒乓球', '羽毛球']],
  email: ctx => {
    return faker.internet.email({ firstName: ctx.firstName, lastName: ctx.secondeName });
  },
  address: addressModel,
  children: {
    // 引用自身，此时必须使用模型别名'user'而不能使用userModel
    refModel: 'user',
    // 控制自引用递归深度
    deep: 3,
  },
});
const userDatas = fakeData(userModel);
console.dir(userDatas, { depth: Infinity });
```

生成的数据如下：

```json{8,15,22,29}
{
  "id": 3104367534645508,
  "firstName": "Emmie",
  "secondeName": "Goyette-Sporer",
  "age": 48,
  "hobby": ["羽毛球", "篮球", "乒乓球"],
  "address": { "country": "Chile", "city": "Samirbury" },
  "children": {
    "id": 6711551880453162,
    "firstName": "Evelyn",
    "secondeName": "Rau",
    "age": 25,
    "hobby": ["乒乓球", "篮球", "足球"],
    "address": { "country": "Sweden", "city": "South Rod" },
    "children": {
      "id": 7905722737546825,
      "firstName": "Haley",
      "secondeName": "Glover",
      "age": 63,
      "hobby": ["篮球", "羽毛球", "乒乓球", "足球"],
      "address": { "country": "Ukraine", "city": "Port Terrell" },
      "children": {
        "id": 3203661997548607,
        "firstName": "Cleta",
        "secondeName": "Bahringer",
        "age": 41,
        "hobby": ["羽毛球", "乒乓球"],
        "address": { "country": "Fiji", "city": "Maggiotown" },
        "children": null,
        "email": "Cleta_Bahringer@gmail.com"
      },
      "email": "Haley_Glover@gmail.com"
    },
    "email": "Evelyn_Rau95@yahoo.com"
  },
  "email": "Emmie.Goyette-Sporer@gmail.com"
}
```

::: tip 关于递归深度
当使用自引用时，默认的递归深度为 1，你可以通过 `deep` 属性来控制递归深度，如果设置为 `0` 则表示不递归，有关于配置项的信息请参考 [数据引用](/zh/数据引用.md)。
:::
